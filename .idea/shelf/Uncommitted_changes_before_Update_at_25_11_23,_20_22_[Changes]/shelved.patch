Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>![alt_text](https://media.discordapp.net/attachments/852653617798185012/1175031954236772402/banner.png)\n\n# **Myths and Mists**\n## A story on love & loss, powered by Lanterna\n\nMyths and Mists is based on the Greek myth of Orpheus and Eurydice, a story about a newlywed couple that turns into a proof of love, an encounter with the underworld and with loss. An unforgettable and touching story that we crafted into a Java interactive adventure, powered by Lanterna.\n\n## Structure\n\nJust like a musical or a play, the game will be divided into 3 different acts: each with its own particularities.\n\n### Act 1: Love at First Sight / Into the Underworld\n\nThe first act will be presented to the user in 2 segments:\n> Love at First Sight\n\n> Into the Underworld\n\n**Love at First Sight**\n\nThe first segment of Act 1 is a text-based story. The window will show the beginning of the myth. A sort of intro. \n\nKeep in mind that, during the game, text-based sentences will be showed, just to keep context of the story and improve the overall storytelling experience.\n\n*It's the boring part, we get that.*\n\n**Into the Underworld**\n\nWithout getting into much detail or spoil, Orpheus will need to go into the Underworld. \n\nIn this level, the base will be the 'hero' tutorial presented in class.\n\nOur 'hero' will be Orpheus, trying to reach the Underworld to talk to Hades, avoiding obstacles.\n\nYou'll have the possibility to retry, if failed.\n\nWhen you reach the Underworld, the window will fade to black. Time for Act 2.\n\n*A true hero shall pass Act 1 at the first try.*\n\n### Act 2: A Sung Promise\n\nThe second act will focus on the Underworld.\n\nStill following a simple approach (or other?), the user will now have to face all of the dangers of the Underworld and have a talk with Hades.\n\nOrpheus is a good singer. So, taking advantage on that, you'll have to sing through the level.\n\nBy clicking on a key, Orpheus will \"shoot\" musical notes out of his mouth. This will make all the obstacles, like Cerberus (the gigantic three-headed hound) to let you pass.\n\nWhen you reach to Hades, you'll have to explain why you are there. A promise will be made.\n\n*Don't look back on a promise.*\n\n### Act 3: Turning Love into Death\n\nAfter the said promise, Orpheus will walk out of the  Underworld.\n\nYou will be presented with a maze and a sentence on top of the screen: \n\"Want to look back? Press [X]\".\n\nAs you go through the maze, you'll have the opportunity to look back.\n\n> Good Ending\n\n> Bad Ending\n\n**Good Ending**\n\nCongratulations. If you reached the good ending, you reached the end of the maze. And you didn't look back, even though the shivering sentence was haunting you all the time. That will prompt the good ending, again, as a text-based segment that explains it.\n\n**Bad Ending**\n\nYou probably did reach the end of the maze. But you looked back. If you were tempted by that sentence, the game is over - the bad ending prompts.\n\n\nThat's how the game ends. Even though in the original story the only ending is our bad ending, we decided to take our twist and implement a second ending, considering that not all players know the myth behind the game.\n\n*All good things must come to an end. The bad ones too.*\n\n## Class diagram\n\n### UML approach\nAs we didn't start coding much yet, this is our current class diagram. Every class name should be understandable due to the game's structural context.\n\n\n![versão1_uml](https://github.com/FEUP-LDTS-2023/project-l13gr02/assets/116096892/1c7257d6-a696-4132-a82d-8ee95967f494)\n\nNeste diagrama:\n* A classe Game representa o jogo em si, que tem títulos, uma lista de atos (Act), e um ato atual.\n* Act representa um ato dentro do jogo, com um título, uma lista de segmentos (Segment), e um segmento atual.\n* Segment é a classe base para diferentes tipos de segmentos no jogo, como HeroSegment para o tutorial do herói, MazeSegment para o labirinto, SingingSegment para o ato de cantar, e EndingSegment para o segmento de término.\n* Option representa as opções disponíveis em um MazeSegment.\n\n## Implemented approaches\n\n## List of features\n\n## Design patterns\n\n## Testing\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
--- a/README.md	
+++ b/README.md	
@@ -83,7 +83,6 @@
 ### UML approach
 As we didn't start coding much yet, this is our current class diagram. Every class name should be understandable due to the game's structural context.
 
-
 ![versão1_uml](https://github.com/FEUP-LDTS-2023/project-l13gr02/assets/116096892/1c7257d6-a696-4132-a82d-8ee95967f494)
 
 Neste diagrama:
@@ -97,6 +96,46 @@
 ## List of features
 
 ## Design patterns
+### State pattern
+
+This behavioral design pattern is an important part of our game. By implementing it, we can allow loading of "scenes".
+
+We started by creating an abstract class called State that requires a Viewer and a Controller.
+
+All together, we can now create a specific State for a level or for a menu.
+
+This state simplifies and improves our code.
+
+### MVC architectural pattern
+
+MVC stands for Model View Controller.
+
+This pattern mostly relates to the UI/interaction layer of our game, allowing these three aspects to work together.
+
+- Model - includes the class code itself, the pure application data and logic.
+
+- Viewer - presents the data to the user, in this case, printing out to the GUI the information specified in the model.
+
+- Controller - exists between the Model and the Viewer, listening to events triggered either by the Viewer or by the user.
+
+
+The most simple example is the user pressing a key to show something ingame: the controller listens to the pressed key, the model processes this input and the viewer outputs it.
+
+This is an important pattern for our project, as it allows all group elements to work simultaneously on the model, controller and viewers while also allowing models to have multiple viewers, something that can really come in handy.
+
+
+### Template method
+
+
+The template method defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.
+
+This behavioral pattern is present in many aspects of our code, for example, in the creation of states, viewers and controllers.
+
+For example:
+- The State abstract class is defined
+- Act1State, Act2State, Act3State classes are defined as extensions of the State class, overriding some of its' functions.
+
+Overall, it is a nice pattern, as we can override only specific parts of the code, making them less suitable to errors triggered by changes to the rest of the code.
 
 ## Testing
 
